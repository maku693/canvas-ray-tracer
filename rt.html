<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Document</title>
</head>
<body>
  <canvas id="canvas" width="600" height="400"></canvas>
  <script>
    (() => {
      'use strict';
      class Vec2 {
        constructor(x, y) {
          this.x = x;
          this.y = y;
        }
      }

      class Vec3 {
        constructor(x, y, z) {
          this.x = x;
          this.y = y;
          this.z = z;
        }
        getNorm() {
          return Math.sqrt(Math.pow(this.x, 2) +
              Math.pow(this.y, 2) +
              Math.pow(this.z, 2));
        }
        normalize() {
          let norm = this.getNorm();
          return new Vec3(
            this.x / norm, 
            this.y / norm, 
            this.z / norm
          );
        }
        multiply(x) {
          return new Vec3(
            this.x * x,
            this.y * x,
            this.z * x
          );
        }

        static subtract(a, b) {
          return new Vec3(a.x - b.x, a.y - b.y, a.z - b.z);
        }
        static innerProd(a, b) {
          return a.x * b.x + a.y * b.y + a.z * b.z;
        }
      }

      class Ray {
        constructor(center, direction) {
          this.center = center;
          this.direction = direction;
        }
      }

      class Sphere {
        constructor(center, radius) {
          this.center = center;
          this.radius = radius;
        }
        getIntersectionPointWithRay(ray) {
          const A = Vec3.innerProd(ray.direction, ray.direction);
          const B = 2 * (Vec3.innerProd(ray.center, ray.direction) -
              Vec3.innerProd(ray.direction, this.center))
          const C = Vec3.innerProd(ray.center, ray.center) +
            Vec3.innerProd(this.center, this.center) -
            2 * Vec3.innerProd(this.center, ray.center) -
            Math.pow(this.radius, 2);
          const D = Math.pow(B, 2) - 4 * A * C;
          if (D >= 0) {
            return null;
          }
          const T = (-1 * B + Math.sqrt(D)) / 2 * A;
          return ray.direction.multiply(T).normalize();
        }
        getNormalForIntersectionPoint(point) {
          return Vec3.subtract(point, this.center).normalize();
        }
        collidesWithRay(ray) {
          const A = Vec3.innerProd(ray.direction, ray.direction);
          const B = 2 * (Vec3.innerProd(ray.center, ray.direction) -
              Vec3.innerProd(ray.direction, this.center))
          const C = Vec3.innerProd(ray.center, ray.center) +
            Vec3.innerProd(this.center, this.center) -
            2 * Vec3.innerProd(this.center, ray.center) -
            Math.pow(this.radius, 2);
          const D = Math.pow(B, 2) - 4 * A * C;
          if (D >= 0) {
            return true;
          } else {
            return false;
          }
        }
      }

      window.addEventListener('DOMContentLoaded', () => {
        let c = canvas.getContext('2d');
        let image = c.createImageData(canvas.width, canvas.height);

        const sRGB_GAMUT = 1 / 2.2;
        const FOCAL_LENGTH = 0.028;
        const FILM_WIDTH = 0.036;
        const FILM_HEIGHT = 0.024;

        for (let y = 0; y < image.height; y++) {
          for (let x = 0; x < image.width; x++) {
            const COORDINATES = new Vec2(x / image.width - 0.5,
                y / image.height - 0.5);
            const RAY_CENTER = new Vec3(0, 1, 0);
            const RAY_DIRECTION = new Vec3(FILM_WIDTH * COORDINATES.x,
                FILM_HEIGHT * COORDINATES.y, FOCAL_LENGTH).normalize();
            const RAY = new Ray(RAY_CENTER, RAY_DIRECTION);

            let color = new Vec3(0, 0, 0);

            // Rendering
            const SPHERE_CENTER = new Vec3(0, 0.5, -5);
            const SPHERE_RADIUS = 1.0;
            const SPHERE = new Sphere(SPHERE_CENTER, SPHERE_RADIUS);
            if (SPHERE.collidesWithRay(RAY)) {
              color.z = 1;
            }

            // Set color
            const HEAD_INDEX = (y * image.width + x) * 4;
            image.data[HEAD_INDEX] = Math.pow(color.x, sRGB_GAMUT) * 255;
            image.data[HEAD_INDEX + 1] = Math.pow(color.y, sRGB_GAMUT) * 255;
            image.data[HEAD_INDEX + 2] = Math.pow(color.z, sRGB_GAMUT) * 255;
            image.data[HEAD_INDEX + 3] = 255;
          }
        }
        c.putImageData(image, 0, 0);
      });
    })();
  </script>
</body>
</html>
